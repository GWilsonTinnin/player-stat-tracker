/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PlayerStatCounterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// view.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_PLAYER_STAT = "player-stat-counter";
var PlayerStatView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.countersList = null;
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_PLAYER_STAT;
  }
  getDisplayText() {
    return "Player Stat Counter";
  }
  onOpen() {
    return __async(this, null, function* () {
      const container = this.containerEl.children[1];
      container.empty();
      container.style.padding = "10px";
      const header = container.createDiv("player-stat-header");
      const title = header.createEl("h2", { text: "Player Counters" });
      title.style.margin = "0 0 10px 0";
      title.style.fontSize = "18px";
      const addButton = header.createEl("button", { text: "+ Add Counter" });
      addButton.style.padding = "8px 16px";
      addButton.style.backgroundColor = "#007acc";
      addButton.style.color = "white";
      addButton.style.border = "none";
      addButton.style.borderRadius = "4px";
      addButton.style.cursor = "pointer";
      addButton.style.fontSize = "14px";
      addButton.style.marginTop = "10px";
      addButton.style.width = "100%";
      addButton.addEventListener("click", () => {
        this.showAddCounterDialog();
      });
      this.countersList = container.createDiv("counters-list");
      this.countersList.style.marginTop = "20px";
      this.renderCounters();
    });
  }
  renderCounters() {
    if (!this.countersList) return;
    this.countersList.empty();
    if (this.plugin.counters.length === 0) {
      this.countersList.createEl("p", {
        text: "No counters yet. Click 'Add Counter' to create one.",
        cls: "placeholder-text"
      });
      this.countersList.style.color = "#888";
      return;
    }
    const colors = ["#E8F4F8", "#FFF4E6"];
    this.plugin.counters.forEach((counter, index) => {
      const bgColor = colors[index % colors.length];
      const counterItem = this.countersList.createDiv("counter-item");
      counterItem.style.marginBottom = "12px";
      counterItem.style.padding = "16px";
      counterItem.style.backgroundColor = bgColor;
      counterItem.style.borderRadius = "8px";
      counterItem.style.border = "none";
      counterItem.style.display = "flex";
      counterItem.style.justifyContent = "space-between";
      counterItem.style.alignItems = "flex-start";
      counterItem.style.minHeight = "60px";
      counterItem.style.boxShadow = "0 2px 4px rgba(0,0,0,0.1)";
      counterItem.style.flexWrap = "wrap";
      counterItem.style.gap = "12px";
      const leftSection = counterItem.createDiv();
      leftSection.style.display = "flex";
      leftSection.style.flexDirection = "column";
      leftSection.style.justifyContent = "center";
      leftSection.style.flex = "1";
      const nameDiv = leftSection.createDiv();
      nameDiv.style.color = "#000";
      nameDiv.style.fontWeight = "bold";
      nameDiv.style.fontSize = "16px";
      nameDiv.style.marginBottom = "4px";
      nameDiv.textContent = counter.key.charAt(0).toUpperCase() + counter.key.slice(1).replace(/-/g, " ");
      const valueDiv = leftSection.createDiv();
      valueDiv.style.color = "#000";
      valueDiv.style.fontSize = "28px";
      valueDiv.style.fontWeight = "bold";
      valueDiv.style.marginBottom = "8px";
      valueDiv.textContent = String(counter.value);
      const latestEntryDiv = leftSection.createDiv();
      latestEntryDiv.style.color = "#555";
      latestEntryDiv.style.fontSize = "12px";
      latestEntryDiv.style.fontStyle = "italic";
      latestEntryDiv.style.maxWidth = "200px";
      latestEntryDiv.style.overflow = "hidden";
      latestEntryDiv.style.textOverflow = "ellipsis";
      latestEntryDiv.style.whiteSpace = "nowrap";
      if (counter.log) {
        const entries = counter.log.split("-").map((e) => e.trim()).filter((e) => e);
        if (entries.length > 0) {
          const latestContent = entries[entries.length - 1];
          latestEntryDiv.textContent = latestContent;
        } else {
          latestEntryDiv.textContent = "No log entries";
        }
      } else {
        latestEntryDiv.textContent = "No log entries";
      }
      const rightSection = counterItem.createDiv();
      rightSection.style.display = "flex";
      rightSection.style.gap = "6px";
      rightSection.style.marginLeft = "12px";
      rightSection.style.flexWrap = "wrap";
      rightSection.style.justifyContent = "flex-end";
      rightSection.style.flex = "1 1 auto";
      rightSection.style.minWidth = "0";
      const decrementBtn = rightSection.createEl("button", { text: "\u2212" });
      this.styleSmallButton(decrementBtn, "#dc3545");
      decrementBtn.addEventListener("click", () => __async(this, null, function* () {
        counter.value = Math.max(this.plugin.settings.minValue, counter.value - 1);
        counter.history.push({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          value: counter.value
        });
        yield this.plugin.saveCounters();
        this.renderCounters();
      }));
      const incrementBtn = rightSection.createEl("button", { text: "+" });
      this.styleSmallButton(incrementBtn, "#28a745");
      incrementBtn.addEventListener("click", () => __async(this, null, function* () {
        const maxVal = this.plugin.settings.maxValue || Infinity;
        counter.value = Math.min(maxVal, counter.value + 1);
        counter.history.push({
          timestamp: (/* @__PURE__ */ new Date()).toISOString(),
          value: counter.value
        });
        yield this.plugin.saveCounters();
        this.renderCounters();
      }));
      const deleteBtn = rightSection.createEl("button", { text: "\u2715" });
      this.styleSmallButton(deleteBtn, "#999");
      deleteBtn.addEventListener("click", () => __async(this, null, function* () {
        if (this.plugin.settings.showDeleteConfirm) {
          if (!confirm(`Delete counter "${counter.key}"?`)) return;
        }
        this.plugin.counters.splice(index, 1);
        yield this.plugin.saveCounters();
        this.renderCounters();
      }));
      const editBtn = rightSection.createEl("button", { text: "\u270E" });
      this.styleSmallButton(editBtn, "#0066cc");
      editBtn.addEventListener("click", () => __async(this, null, function* () {
        this.showEditCounterDialog(counter);
      }));
      const manualBtn = rightSection.createEl("button", { text: "\xB1" });
      this.styleSmallButton(manualBtn, "#6f42c1");
      manualBtn.addEventListener("click", () => __async(this, null, function* () {
        this.showManualEntryDialog(counter);
      }));
    });
  }
  styleSmallButton(btn, bgColor) {
    btn.style.padding = "6px 12px";
    btn.style.backgroundColor = bgColor;
    btn.style.color = "white";
    btn.style.border = "none";
    btn.style.borderRadius = "4px";
    btn.style.cursor = "pointer";
    btn.style.fontSize = "14px";
    btn.style.fontWeight = "bold";
    btn.style.whiteSpace = "nowrap";
    btn.style.minWidth = "auto";
    btn.style.flex = "0 1 auto";
  }
  showAddCounterDialog() {
    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "50%";
    modal.style.left = "50%";
    modal.style.transform = "translate(-50%, -50%)";
    modal.style.backgroundColor = "var(--background-primary)";
    modal.style.border = "1px solid var(--divider-color)";
    modal.style.borderRadius = "8px";
    modal.style.padding = "20px";
    modal.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    modal.style.zIndex = "1000";
    modal.style.minWidth = "300px";
    modal.style.maxHeight = "80vh";
    modal.style.overflowY = "auto";
    const title = modal.createEl("h3", { text: "Add Counter" });
    title.style.marginTop = "0";
    const form = modal.createDiv("form");
    const nameLabel = form.createEl("label", { text: "Counter Name:" });
    nameLabel.style.display = "block";
    nameLabel.style.marginBottom = "10px";
    nameLabel.style.fontWeight = "bold";
    const nameInput = form.createEl("input", {
      type: "text",
      placeholder: "e.g., Health, Mana"
    });
    nameInput.style.width = "100%";
    nameInput.style.padding = "10px";
    nameInput.style.marginBottom = "15px";
    nameInput.style.border = "1px solid var(--divider-color)";
    nameInput.style.borderRadius = "4px";
    nameInput.style.boxSizing = "border-box";
    nameInput.style.fontSize = "16px";
    const logLabel = form.createEl("label", { text: "Log/Comment (optional):" });
    logLabel.style.display = "block";
    logLabel.style.marginBottom = "10px";
    logLabel.style.fontWeight = "bold";
    const logInput = form.createEl("textarea", {
      placeholder: "e.g., Notes about this counter"
    });
    logInput.style.width = "100%";
    logInput.style.padding = "10px";
    logInput.style.marginBottom = "15px";
    logInput.style.border = "1px solid var(--divider-color)";
    logInput.style.borderRadius = "4px";
    logInput.style.boxSizing = "border-box";
    logInput.style.fontSize = "16px";
    logInput.style.minHeight = "80px";
    const varLabel = form.createEl("label", { text: "Variable Reference:" });
    varLabel.style.display = "block";
    varLabel.style.marginBottom = "10px";
    varLabel.style.fontWeight = "bold";
    const varDiv = form.createDiv();
    varDiv.style.padding = "8px";
    varDiv.style.backgroundColor = "var(--background-secondary)";
    varDiv.style.borderRadius = "4px";
    varDiv.style.marginBottom = "15px";
    varDiv.style.fontFamily = "monospace";
    varDiv.style.fontSize = "12px";
    varDiv.style.wordBreak = "break-all";
    varDiv.style.cursor = "pointer";
    varDiv.style.userSelect = "all";
    const generateVarRef = (name) => {
      const varName = name.toLowerCase().replace(/\s+/g, "_");
      return `{{${varName}}}`;
    };
    const buttonContainer = form.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const createBtn = buttonContainer.createEl("button", { text: "Create" });
    createBtn.style.padding = "8px 16px";
    createBtn.style.backgroundColor = "#28a745";
    createBtn.style.color = "white";
    createBtn.style.border = "none";
    createBtn.style.borderRadius = "4px";
    createBtn.style.cursor = "pointer";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.style.padding = "8px 16px";
    cancelBtn.style.backgroundColor = "#6c757d";
    cancelBtn.style.color = "white";
    cancelBtn.style.border = "none";
    cancelBtn.style.borderRadius = "4px";
    cancelBtn.style.cursor = "pointer";
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    overlay.style.zIndex = "999";
    createBtn.addEventListener("click", () => __async(this, null, function* () {
      const counterName = nameInput.value.trim();
      if (counterName) {
        const newCounter = {
          key: counterName.toLowerCase().replace(/\s+/g, "_"),
          type: "simple",
          value: 0,
          log: logInput.value.trim(),
          history: [{ timestamp: (/* @__PURE__ */ new Date()).toISOString(), value: 0 }]
        };
        this.plugin.counters.push(newCounter);
        console.log("Counter created:", newCounter);
        yield this.plugin.saveCounters();
        overlay.remove();
        modal.remove();
        this.renderCounters();
      }
    }));
    cancelBtn.addEventListener("click", () => {
      overlay.remove();
      modal.remove();
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
        modal.remove();
      }
    });
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    nameInput.focus();
  }
  showEditCounterDialog(counter) {
    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "50%";
    modal.style.left = "50%";
    modal.style.transform = "translate(-50%, -50%)";
    modal.style.backgroundColor = "var(--background-primary)";
    modal.style.border = "1px solid var(--divider-color)";
    modal.style.borderRadius = "8px";
    modal.style.padding = "20px";
    modal.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    modal.style.zIndex = "1000";
    modal.style.minWidth = "300px";
    modal.style.maxHeight = "80vh";
    modal.style.overflowY = "auto";
    const title = modal.createEl("h3", { text: "Edit Counter" });
    title.style.marginTop = "0";
    const form = modal.createDiv("form");
    const nameLabel = form.createEl("label", { text: "Counter Name:" });
    nameLabel.style.display = "block";
    nameLabel.style.marginBottom = "5px";
    nameLabel.style.fontWeight = "bold";
    const nameInput = form.createEl("input", {
      type: "text",
      placeholder: "e.g., Health, Mana, Experience"
    });
    nameInput.value = counter.key.charAt(0).toUpperCase() + counter.key.slice(1).replace(/-/g, " ");
    nameInput.style.width = "100%";
    nameInput.style.padding = "8px";
    nameInput.style.marginBottom = "15px";
    nameInput.style.border = "1px solid var(--divider-color)";
    nameInput.style.borderRadius = "4px";
    nameInput.style.boxSizing = "border-box";
    const logLabel = form.createEl("label", { text: "Log/Notes:" });
    logLabel.style.display = "block";
    logLabel.style.marginBottom = "5px";
    logLabel.style.fontWeight = "bold";
    const logInput = form.createEl("textarea");
    logInput.placeholder = "Add notes or log information about this counter";
    logInput.value = counter.log || "";
    logInput.style.width = "100%";
    logInput.style.padding = "8px";
    logInput.style.marginBottom = "15px";
    logInput.style.border = "1px solid var(--divider-color)";
    logInput.style.borderRadius = "4px";
    logInput.style.boxSizing = "border-box";
    logInput.style.minHeight = "100px";
    logInput.style.fontFamily = "monospace";
    logInput.style.fontSize = "12px";
    const varLabel = form.createEl("label", { text: "Variable Reference:" });
    varLabel.style.display = "block";
    varLabel.style.marginBottom = "5px";
    varLabel.style.fontWeight = "bold";
    varLabel.style.fontSize = "12px";
    const varDiv = form.createDiv();
    varDiv.style.padding = "8px";
    varDiv.style.backgroundColor = "var(--background-secondary)";
    varDiv.style.borderRadius = "4px";
    varDiv.style.marginBottom = "15px";
    varDiv.style.fontFamily = "monospace";
    varDiv.style.fontSize = "12px";
    varDiv.style.wordBreak = "break-all";
    varDiv.style.cursor = "pointer";
    varDiv.style.userSelect = "all";
    const generateVarRef = (name) => {
      const varName = name.toLowerCase().replace(/\s+/g, "_");
      return `{{${varName}}}`;
    };
    const updateVarDisplay = () => {
      varDiv.textContent = generateVarRef(nameInput.value.trim() || "counter");
    };
    updateVarDisplay();
    nameInput.addEventListener("input", updateVarDisplay);
    varDiv.addEventListener("click", () => {
      const text = varDiv.textContent || "";
      navigator.clipboard.writeText(text).then(() => {
        const originalBg = varDiv.style.backgroundColor;
        varDiv.style.backgroundColor = "#28a745";
        varDiv.style.color = "white";
        setTimeout(() => {
          varDiv.style.backgroundColor = originalBg;
          varDiv.style.color = "";
        }, 200);
      });
    });
    const buttonContainer = form.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const saveBtn = buttonContainer.createEl("button", { text: "Save" });
    saveBtn.style.padding = "8px 16px";
    saveBtn.style.backgroundColor = "#007bff";
    saveBtn.style.color = "white";
    saveBtn.style.border = "none";
    saveBtn.style.borderRadius = "4px";
    saveBtn.style.cursor = "pointer";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.style.padding = "8px 16px";
    cancelBtn.style.backgroundColor = "#6c757d";
    cancelBtn.style.color = "white";
    cancelBtn.style.border = "none";
    cancelBtn.style.borderRadius = "4px";
    cancelBtn.style.cursor = "pointer";
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    overlay.style.zIndex = "999";
    saveBtn.addEventListener("click", () => __async(this, null, function* () {
      const newName = nameInput.value.trim();
      if (newName) {
        counter.key = newName.toLowerCase().replace(/\s+/g, "_");
        counter.log = logInput.value.trim();
        yield this.plugin.saveCounters();
        overlay.remove();
        modal.remove();
        this.renderCounters();
      }
    }));
    cancelBtn.addEventListener("click", () => {
      overlay.remove();
      modal.remove();
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
        modal.remove();
      }
    });
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    nameInput.focus();
  }
  showManualEntryDialog(counter) {
    const modal = document.createElement("div");
    modal.style.position = "fixed";
    modal.style.top = "50%";
    modal.style.left = "50%";
    modal.style.transform = "translate(-50%, -50%)";
    modal.style.backgroundColor = "var(--background-primary)";
    modal.style.border = "1px solid var(--divider-color)";
    modal.style.borderRadius = "8px";
    modal.style.padding = "20px";
    modal.style.boxShadow = "0 4px 12px rgba(0, 0, 0, 0.3)";
    modal.style.zIndex = "1000";
    modal.style.minWidth = "300px";
    const title = modal.createEl("h3", { text: `Adjust ${counter.key.charAt(0).toUpperCase() + counter.key.slice(1).replace(/-/g, " ")}` });
    title.style.marginTop = "0";
    const form = modal.createDiv("form");
    const label = form.createEl("label", { text: "Enter value to add or subtract:" });
    label.style.display = "block";
    label.style.marginBottom = "10px";
    label.style.fontWeight = "bold";
    const input = form.createEl("input", {
      type: "number",
      placeholder: "e.g., 5 or -3"
    });
    input.style.width = "100%";
    input.style.padding = "10px";
    input.style.marginBottom = "15px";
    input.style.border = "1px solid var(--divider-color)";
    input.style.borderRadius = "4px";
    input.style.boxSizing = "border-box";
    input.style.fontSize = "16px";
    const currentValueDiv = form.createDiv();
    currentValueDiv.style.marginBottom = "15px";
    currentValueDiv.style.padding = "10px";
    currentValueDiv.style.backgroundColor = "var(--background-secondary)";
    currentValueDiv.style.borderRadius = "4px";
    currentValueDiv.textContent = `Current value: ${counter.value}`;
    const previewDiv = form.createDiv();
    previewDiv.style.marginBottom = "15px";
    previewDiv.style.padding = "10px";
    previewDiv.style.backgroundColor = "var(--background-secondary)";
    previewDiv.style.borderRadius = "4px";
    previewDiv.textContent = `New value will be: ${counter.value}`;
    input.addEventListener("input", () => {
      const num = parseInt(input.value) || 0;
      const newValue = counter.value + num;
      previewDiv.textContent = `New value will be: ${newValue}`;
    });
    const buttonContainer = form.createDiv();
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const confirmBtn = buttonContainer.createEl("button", { text: "Apply" });
    confirmBtn.style.padding = "8px 16px";
    confirmBtn.style.backgroundColor = "#28a745";
    confirmBtn.style.color = "white";
    confirmBtn.style.border = "none";
    confirmBtn.style.borderRadius = "4px";
    confirmBtn.style.cursor = "pointer";
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.style.padding = "8px 16px";
    cancelBtn.style.backgroundColor = "#6c757d";
    cancelBtn.style.color = "white";
    cancelBtn.style.border = "none";
    cancelBtn.style.borderRadius = "4px";
    cancelBtn.style.cursor = "pointer";
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
    overlay.style.zIndex = "999";
    confirmBtn.addEventListener("click", () => __async(this, null, function* () {
      const num = parseInt(input.value) || 0;
      const maxVal = this.plugin.settings.maxValue || Infinity;
      const newValue = Math.min(maxVal, Math.max(this.plugin.settings.minValue, counter.value + num));
      counter.value = newValue;
      counter.history.push({
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        value: counter.value
      });
      yield this.plugin.saveCounters();
      overlay.remove();
      modal.remove();
      this.renderCounters();
    }));
    cancelBtn.addEventListener("click", () => {
      overlay.remove();
      modal.remove();
    });
    overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {
        overlay.remove();
        modal.remove();
      }
    });
    document.body.appendChild(overlay);
    document.body.appendChild(modal);
    input.focus();
  }
  onClose() {
    return __async(this, null, function* () {
    });
  }
};

// settings.ts
var import_obsidian2 = require("obsidian");
var PlayerStatSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Player Stat Counter Settings" });
    new import_obsidian2.Setting(containerEl).setName("Counter display format").setDesc("Choose how counters are displayed").addDropdown(
      (dropdown) => dropdown.addOption("compact", "Compact (value only)").addOption("full", "Full (name + value)").setValue(this.plugin.settings.displayFormat).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.displayFormat = value;
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Enable counter history").setDesc("Keep track of all counter changes with timestamps").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.trackHistory).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.trackHistory = value;
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Show delete confirmation").setDesc("Ask for confirmation before deleting a counter").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showDeleteConfirm).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.showDeleteConfirm = value;
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Minimum counter value").setDesc("Set the minimum value counters can reach").addText(
      (text) => text.setPlaceholder("0").setValue(String(this.plugin.settings.minValue)).onChange((value) => __async(this, null, function* () {
        const num = parseInt(value);
        if (!isNaN(num)) {
          this.plugin.settings.minValue = num;
          yield this.plugin.saveSettings();
        }
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Maximum counter value").setDesc("Set the maximum value counters can reach (leave empty for unlimited)").addText(
      (text) => text.setPlaceholder("unlimited").setValue(this.plugin.settings.maxValue ? String(this.plugin.settings.maxValue) : "").onChange((value) => __async(this, null, function* () {
        const num = value === "" ? 0 : parseInt(value);
        if (value === "" || !isNaN(num)) {
          this.plugin.settings.maxValue = num;
          yield this.plugin.saveSettings();
        }
      }))
    );
    new import_obsidian2.Setting(containerEl).setName("Button style").setDesc("Choose button appearance").addDropdown(
      (dropdown) => dropdown.addOption("default", "Default").addOption("large", "Large").addOption("minimal", "Minimal").setValue(this.plugin.settings.buttonStyle).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.buttonStyle = value;
        yield this.plugin.saveSettings();
      }))
    );
    containerEl.createEl("hr");
    containerEl.createEl("h3", { text: "Data Management" });
    new import_obsidian2.Setting(containerEl).setName("Export counters").setDesc("Download your counter data as JSON").addButton(
      (button) => button.setButtonText("Export").onClick(() => {
        const dataStr = JSON.stringify(this.plugin.counters, null, 2);
        const dataBlob = new Blob([dataStr], { type: "application/json" });
        const url = URL.createObjectURL(dataBlob);
        const link = document.createElement("a");
        link.href = url;
        link.download = `player-counters-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.json`;
        link.click();
        URL.revokeObjectURL(url);
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Clear all counters").setDesc("WARNING: This will delete all counters permanently").addButton(
      (button) => button.setButtonText("Clear All").setWarning().onClick(() => __async(this, null, function* () {
        if (confirm("Are you sure you want to delete all counters? This cannot be undone.")) {
          this.plugin.counters = [];
          yield this.plugin.saveCounters();
          this.display();
        }
      }))
    );
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  displayFormat: "full",
  trackHistory: true,
  showDeleteConfirm: true,
  minValue: 0,
  maxValue: 0,
  buttonStyle: "default"
};
var PlayerStatCounterPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.view = null;
    this.counters = [];
    this.settings = DEFAULT_SETTINGS;
    this.variableElements = /* @__PURE__ */ new Map();
  }
  // Track replaced elements
  onload() {
    return __async(this, null, function* () {
      const savedSettings = yield this.loadData();
      if (savedSettings && savedSettings.settings) {
        this.settings = __spreadValues(__spreadValues({}, DEFAULT_SETTINGS), savedSettings.settings);
      }
      if (savedSettings && savedSettings.counters) {
        this.counters = savedSettings.counters;
      }
      this.addPluginStyles();
      this.addSettingTab(new PlayerStatSettingTab(this.app, this));
      this.registerView(
        VIEW_TYPE_PLAYER_STAT,
        (leaf) => {
          this.view = new PlayerStatView(leaf, this);
          return this.view;
        }
      );
      this.addRibbonIcon("dice", "Player Stat Counter", () => {
        this.activateView();
      });
      this.addCommand({
        id: "open-player-stat-counter",
        name: "Open Player Stat Counter",
        callback: () => this.activateView()
      });
      this.addCommand({
        id: "debug-player-stat-dom",
        name: "Debug: Inspect DOM for variables",
        callback: () => {
          console.log("=== Inspecting DOM for variable references ===");
          const container = document.querySelector(".markdown-preview-view");
          if (!container) {
            console.log("No markdown preview container found");
            return;
          }
          console.log("Container HTML:", container.innerHTML.substring(0, 500));
          const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_TEXT,
            null,
            false
          );
          let node;
          let nodeCount = 0;
          while (node = walker.nextNode()) {
            const text = node.textContent || "";
            if (text.includes("<") || text.includes(">") || text.includes("health") || text.includes("dean") || text.includes("mana")) {
              console.log(`Text node ${nodeCount}: "${text}"`);
            }
            nodeCount++;
          }
          const varLinks = container.querySelectorAll(".player-stat-variable");
          console.log(`Found ${varLinks.length} .player-stat-variable elements`);
          varLinks.forEach((el, i) => {
            console.log(`  Link ${i}: key="${el.getAttribute("data-counter-key")}", text="${el.textContent}"`);
          });
        }
      });
      this.addCommand({
        id: "debug-player-stat-css",
        name: "Debug: Check Variable Links in DOM",
        callback: () => {
          console.log("=== DEBUG: Searching for variable links ===");
          const links = document.querySelectorAll(".player-stat-variable");
          console.log(`Found ${links.length} variable links in the DOM`);
          const internalLinks = document.querySelectorAll(".internal-link");
          console.log(`Found ${internalLinks.length} total internal links`);
          const mdContainers = document.querySelectorAll(".markdown-reading-view, .markdown-preview-view");
          console.log(`Found ${mdContainers.length} markdown containers`);
          mdContainers.forEach((container, i) => {
            const varLinksInContainer = container.querySelectorAll(".player-stat-variable");
            console.log(`  Container ${i}: ${varLinksInContainer.length} variable links`);
          });
          links.forEach((link, i) => {
            const key = link.getAttribute("data-counter-key");
            const value = link.textContent;
            const computedStyle = window.getComputedStyle(link);
            console.log(`Link ${i}: key="${key}", value="${value}", color="${computedStyle.color}", background="${computedStyle.backgroundColor}"`);
          });
        }
      });
      this.addCommand({
        id: "refresh-player-stat-variables",
        name: "Refresh Player Stat Variables",
        callback: () => {
          this.app.workspace.updateOptions();
        }
      });
      console.log("[PlayerStat] Registering markdown post-processor...");
      this.registerMarkdownPostProcessor((el, ctx) => {
        var _a;
        console.log("[PlayerStat] \u2713\u2713\u2713 POST-PROCESSOR CALLED \u2713\u2713\u2713");
        console.log("  tagName:", el.tagName);
        console.log("  innerHTML:", (_a = el.innerHTML) == null ? void 0 : _a.substring(0, 100));
        this.replaceVariablesInElement(el);
      });
      console.log("[PlayerStat] \u2713 Post-processor registered successfully");
      console.log("[PlayerStat] Attempting initial scan of existing markdown...");
      setTimeout(() => {
        this.scanAndReplaceVariables();
      }, 500);
      this.registerInterval(
        window.setInterval(() => {
          this.updateAllVariables();
        }, 500)
        // Update variable values every 500ms
      );
    });
  }
  replaceVariablesInElement(element) {
    var _a;
    console.log(`[PlayerStat] Replace variables in element, tagName: ${element.tagName}`);
    console.log(`[PlayerStat] Element content: "${(_a = element.textContent) == null ? void 0 : _a.substring(0, 100)}"`);
    const fullText = element.textContent || "";
    const variableMatches = fullText.match(/{{[\w_]+}}/g) || [];
    console.log(`[PlayerStat] Full text analysis found ${variableMatches.length} potential variables: ${variableMatches.join(", ")}`);
    variableMatches.forEach((varRef) => {
      const key = varRef.slice(2, -2);
      console.log(`[PlayerStat] Attempting to replace variable: ${varRef} (key: ${key})`);
      this.findAndReplaceVariable(element, varRef, key);
    });
  }
  findAndReplaceVariable(container, varRef, key) {
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    let node;
    const nodesToProcess = [];
    while (node = walker.nextNode()) {
      const parent = node.parentElement;
      if (parent == null ? void 0 : parent.classList.contains("player-stat-variable")) {
        continue;
      }
      const text = node.textContent || "";
      if (text.includes("<") || text === key || text.includes(">")) {
        nodesToProcess.push({ node, varRef, key });
      }
    }
    if (nodesToProcess.length > 0) {
      console.log(`[PlayerStat] Found ${nodesToProcess.length} nodes that might be part of variable ${varRef}`);
      const wholeMatch = nodesToProcess.find(
        ({ node: node2 }) => (node2.textContent || "").includes(varRef)
      );
      if (wholeMatch) {
        console.log(`[PlayerStat] Found whole variable in single node: ${varRef}`);
        this.replaceVariablesInNode(wholeMatch.node);
      } else {
        console.log(`[PlayerStat] Variable ${varRef} is fragmented across multiple nodes, attempting reconstruction...`);
        this.reconstructAndReplaceFragmentedVariable(container, varRef, key);
      }
    }
  }
  reconstructAndReplaceFragmentedVariable(container, varRef, key) {
    console.log(`[PlayerStat] Attempting to reconstruct fragmented variable: ${varRef}`);
    const counter = this.counters.find((c) => c.key === key);
    if (!counter) {
      console.log(`[PlayerStat] Counter not found: ${key}`);
      return;
    }
    console.log(`[PlayerStat] \u2713 Found counter: ${key} = ${counter.value}`);
    const link = document.createElement("a");
    link.className = "player-stat-variable internal-link";
    link.setAttribute("data-counter-key", key);
    link.setAttribute("href", `#${key}`);
    link.textContent = String(counter.value);
    const walker = document.createTreeWalker(
      container,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );
    const allNodes = [];
    let node;
    while (node = walker.nextNode()) {
      allNodes.push(node);
    }
    console.log(`[PlayerStat] Collected ${allNodes.length} text nodes for fragmented search`);
    allNodes.forEach((n, idx) => {
      console.log(`  Node ${idx}: "${n.textContent}"`);
    });
    for (let i = 0; i < allNodes.length; i++) {
      const currentText = allNodes[i].textContent || "";
      if (currentText.includes(key) || currentText === "{" || currentText.includes("{")) {
        console.log(`[PlayerStat] Node ${i} might contain variable: "${currentText}"`);
        let startIdx = i;
        let endIdx = i;
        for (let j = i; j >= Math.max(0, i - 5); j--) {
          const text = allNodes[j].textContent || "";
          if (text.includes("{{") || j < i && (text === "{" || text === "{{")) {
            startIdx = j;
            break;
          }
        }
        for (let j = i; j <= Math.min(allNodes.length - 1, i + 5); j++) {
          const text = allNodes[j].textContent || "";
          if (text.includes("}}") || j > i && (text === "}" || text === "}}")) {
            endIdx = j;
            break;
          }
        }
        let reconstructed = "";
        for (let j = startIdx; j <= endIdx; j++) {
          reconstructed += allNodes[j].textContent;
        }
        console.log(`[PlayerStat] Reconstructed from nodes ${startIdx}-${endIdx}: "${reconstructed}"`);
        if (reconstructed.includes(varRef)) {
          console.log(`[PlayerStat] \u2713 Match found! Replacing nodes ${startIdx} to ${endIdx}`);
          const parent = allNodes[startIdx].parentNode;
          if (parent) {
            parent.insertBefore(link, allNodes[startIdx]);
            for (let j = startIdx; j <= endIdx; j++) {
              if (allNodes[j].parentNode) {
                allNodes[j].parentNode.removeChild(allNodes[j]);
              }
            }
            this.attachLinkListeners(link);
            console.log(`[PlayerStat] \u2713 Successfully replaced fragmented variable ${varRef}`);
            return;
          }
        }
      }
    }
    console.log(`[PlayerStat] \u2717 Could not reconstruct fragmented variable: ${varRef}`);
  }
  scanAndReplaceVariables() {
    console.log("[PlayerStat] Scanning DOM for markdown containers...");
    const previews = document.querySelectorAll(".markdown-preview-view, .markdown-rendered, .cm-content");
    console.log(`[PlayerStat] Found ${previews.length} potential markdown containers`);
    previews.forEach((preview, idx) => {
      console.log(`[PlayerStat] Scanning container ${idx}...`);
      const text = preview.textContent || "";
      console.log(`[PlayerStat] Container ${idx} text preview: "${text.substring(0, 150)}"`);
      const unreplacedVars = text.match(/{{[\w_]+}}/g);
      if (unreplacedVars) {
        console.log(`[PlayerStat] Found unreplaced variables in container ${idx}: ${unreplacedVars.join(", ")}`);
      }
      this.replaceVariablesInElement(preview);
    });
  }
  updateAllVariables() {
    const variableLinks = document.querySelectorAll(".player-stat-variable");
    if (variableLinks.length > 0) {
      console.log(`[PlayerStat] updateAllVariables: Found ${variableLinks.length} variable links`);
    }
    variableLinks.forEach((link, idx) => {
      const counterKey = link.getAttribute("data-counter-key");
      if (!counterKey) {
        console.log(`[PlayerStat] Link ${idx}: No data-counter-key attribute`);
        return;
      }
      const counter = this.counters.find((c) => c.key === counterKey);
      const currentText = link.textContent || "";
      const expectedValue = counter ? String(counter.value) : "NOT FOUND";
      if (counter && link.textContent !== String(counter.value)) {
        console.log(`[PlayerStat] Updating link ${idx}: "${currentText}" -> "${counter.value}"`);
        link.textContent = String(counter.value);
      } else if (!counter) {
        console.log(`[PlayerStat] Link ${idx}: Counter "${counterKey}" not found. Current text: "${currentText}"`);
      }
    });
  }
  replaceVariablesInNode(node) {
    const text = node.textContent || "";
    const parent = node.parentNode;
    if (!parent) return;
    console.log(`[PlayerStat] Replacing in node: "${text}"`);
    console.log(`[PlayerStat] Available counters: ${this.counters.map((c) => `${c.key}=${c.value}`).join(", ")}`);
    const fragment = document.createDocumentFragment();
    let lastIndex = 0;
    const regex = /{{([\w_]+)}}/g;
    let match;
    let hasReplacement = false;
    const createdLinks = [];
    while ((match = regex.exec(text)) !== null) {
      console.log(`[PlayerStat] Found variable match: "${match[0]}" -> key: "${match[1]}"`);
      if (match.index > lastIndex) {
        fragment.appendChild(
          document.createTextNode(text.substring(lastIndex, match.index))
        );
      }
      const counterKey = match[1];
      const counter = this.counters.find((c) => c.key === counterKey);
      if (counter !== void 0) {
        console.log(`[PlayerStat] \u2713 Found counter: ${counterKey} = ${counter.value}`);
        const link = document.createElement("a");
        link.className = "player-stat-variable internal-link";
        link.setAttribute("data-counter-key", counterKey);
        link.setAttribute("href", `#${counterKey}`);
        link.textContent = String(counter.value);
        fragment.appendChild(link);
        createdLinks.push(link);
        hasReplacement = true;
      } else {
        console.log(`[PlayerStat] \u2717 Counter NOT found: ${counterKey}`);
        fragment.appendChild(document.createTextNode(match[0]));
      }
      lastIndex = regex.lastIndex;
    }
    if (hasReplacement) {
      console.log(`[PlayerStat] \u2713 Replacing node with ${createdLinks.length} variable links`);
      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
      }
      parent.replaceChild(fragment, node);
      createdLinks.forEach((link) => {
        this.attachLinkListeners(link);
      });
    } else {
      console.log(`[PlayerStat] \u2717 No replacements made for this node`);
    }
  }
  attachLinkListeners(link) {
    link.addEventListener("click", (e) => {
      e.preventDefault();
      const counterKey = link.getAttribute("data-counter-key");
      this.activateView();
      console.log(`Clicked counter variable: ${counterKey}`);
    });
  }
  registerDataviewSource() {
    const api = window.DataviewAPI;
    if (api) {
      try {
        const counterSource = {
          name: "PlayerStatCounter",
          display: "Player Stat Counters",
          icon: "dice",
          parse: () => {
            return this.counters.map((counter) => __spreadProps(__spreadValues({}, counter), {
              key: counter.key,
              value: counter.value,
              type: counter.type,
              log: counter.log || "",
              history: counter.history
            }));
          }
        };
      } catch (e) {
        console.log("Dataview not available or integration not supported");
      }
    }
  }
  // Helper method to get counter by key (for external access)
  getCounterValue(key) {
    const counter = this.counters.find((c) => c.key === key);
    return counter ? counter.value : null;
  }
  activateView() {
    return __async(this, null, function* () {
      this.app.workspace.getRightLeaf(false).setViewState({
        type: VIEW_TYPE_PLAYER_STAT,
        active: true
      });
    });
  }
  saveCounters() {
    return __async(this, null, function* () {
      yield this.saveData({ counters: this.counters, settings: this.settings });
      this.refreshMarkdownVariables();
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData({ counters: this.counters, settings: this.settings });
    });
  }
  refreshMarkdownVariables() {
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    leaves.forEach((leaf) => {
      var _a;
      const view = leaf.view;
      if (view && view.containerEl) {
        (_a = view.previewMode) == null ? void 0 : _a.rerender(true);
      }
    });
  }
  addPluginStyles() {
    const css = `
      /* Player Stat Tracker - Variable Link Styling */

      /* Main variable link styling */
      .markdown-reading-view a.player-stat-variable,
      .markdown-preview-view a.player-stat-variable,
      a.player-stat-variable {
        font-weight: bold !important;
        color: #0066cc !important;
        cursor: pointer !important;
        text-decoration: none !important;
        border-bottom: 1px solid #0066cc !important;
        padding: 0 2px !important;
        border-radius: 2px !important;
        transition: all 0.15s ease !important;
        display: inline-block !important;
        background-color: transparent !important;
      }

      /* Hover state - light blue background */
      .markdown-reading-view a.player-stat-variable:hover,
      .markdown-preview-view a.player-stat-variable:hover,
      a.player-stat-variable:hover {
        background-color: rgba(0, 102, 204, 0.2) !important;
        border-bottom-width: 2px !important;
        padding-bottom: 1px !important;
        box-shadow: 0 0 6px rgba(0, 102, 204, 0.3) !important;
      }

      /* Active/click state - darker blue background */
      .markdown-reading-view a.player-stat-variable:active,
      .markdown-preview-view a.player-stat-variable:active,
      a.player-stat-variable:active {
        background-color: rgba(0, 102, 204, 0.3) !important;
        border-bottom-width: 2px !important;
      }

      /* Dark mode support */
      body.theme-dark .markdown-reading-view a.player-stat-variable,
      body.theme-dark .markdown-preview-view a.player-stat-variable,
      body.theme-dark a.player-stat-variable {
        color: #5c9cff !important;
        border-bottom-color: #5c9cff !important;
      }

      body.theme-dark .markdown-reading-view a.player-stat-variable:hover,
      body.theme-dark .markdown-preview-view a.player-stat-variable:hover,
      body.theme-dark a.player-stat-variable:hover {
        background-color: rgba(92, 156, 255, 0.2) !important;
        box-shadow: 0 0 6px rgba(92, 156, 255, 0.3) !important;
      }

      body.theme-dark .markdown-reading-view a.player-stat-variable:active,
      body.theme-dark .markdown-preview-view a.player-stat-variable:active,
      body.theme-dark a.player-stat-variable:active {
        background-color: rgba(92, 156, 255, 0.3) !important;
      }
    `;
    const style = document.createElement("style");
    style.id = "player-stat-tracker-styles";
    style.textContent = css;
    document.head.appendChild(style);
    console.log("[PlayerStat] CSS styles injected into document");
    setTimeout(() => {
      var _a, _b;
      const injectedStyle = document.getElementById("player-stat-tracker-styles");
      if (injectedStyle) {
        console.log("[PlayerStat] \u2713 CSS style element found in DOM");
        const rules = ((_b = (_a = injectedStyle.sheet) == null ? void 0 : _a.cssRules) == null ? void 0 : _b.length) || 0;
        console.log(`[PlayerStat] \u2713 CSS rules loaded: ${rules}`);
      } else {
        console.log("[PlayerStat] \u2717 CSS style element NOT found in DOM");
      }
    }, 100);
  }
};
